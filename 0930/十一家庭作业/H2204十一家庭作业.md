## 十一家庭作业

班级：H2204

时间：2022年9月30日

老师：杨标

---

1. cookie sessionStorage localStorage区别？

   ```
   localStorage和sessionStorage是在window上,而cookie是在window.document上
   localStorage可以跨页面共享值,sessionStorage只能父子页之间共享值,cookie的path会隔离，⼦级的path可以访问⽗级的path，⽗级的访问不了⼦级的，同级别的 path 也是可以相互访问的
   localStorage如果不手动清除会一直存在，sessionStorage关闭浏览器就会清除，cookie可以设置过期时间，过期就会清除
   localStorage和sessionStorage不能跨域访问，cookie可以跨域访问
   ```

   

2. HTTP状态码有哪些？常用的状态码有哪些？

   ```
   1xx：信息响应类，表示接收到请求并且继续处理
   2xx：处理成功响应类，表示动作被成功接收、理解和接受
   3xx：重定向响应类，为了完成指定的动作，必须接受进一步处理
   4xx：客户端错误，客户请求包含语法错误或者是不能正确执行
   5xx：服务端错误，服务器不能正确执行一个正确的请求
    
   100——客户必须继续发出请求
   101——客户要求服务器根据请求转换HTTP协议版本
   200——交易成功
   201——提示知道新文件的URL
   202——接受和处理、但处理未完成
   203——返回信息不确定或不完整
   204——请求收到，但返回信息为空
   205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
   206——服务器已经完成了部分用户的GET请求
   300——请求的资源可在多处得到
   301——删除请求数据
   302——在其他地址发现了请求数据
   303——建议客户访问其他URL或访问方式
   304——客户端已经执行了GET，但文件未变化
   305——请求的资源必须从服务器指定的地址得到
   306——前一版本HTTP中使用的代码，现行版本中不再使用
   307——申明请求的资源临时性删除
   400——错误请求，如语法错误
   401——请求授权失败
   402——保留有效ChargeTo头响应
   403——请求不允许
   404——没有发现文件、查询或URl
   405——用户在Request-Line字段定义的方法不允许
   406——根据用户发送的Accept拖，请求资源不可访问
   407——类似401，用户必须首先在代理服务器上得到授权
   408——客户端没有在用户指定的饿时间内完成请求
   409——对当前资源状态，请求不能完成
   410——服务器上不再有此资源且无进一步的参考地址
   411——服务器拒绝用户定义的Content-Length属性请求
   412——一个或多个请求头字段在当前请求中错误
   413——请求的资源大于服务器允许的大小
   414——请求的资源URL长于服务器允许的长度
   415——请求资源不支持请求项目格式
   416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
   417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
   500——服务器产生内部错误
   501——服务器不支持请求的函数
   502——服务器暂时不可用，有时是为了防止发生系统过载
   503——服务器过载或暂停维修
   504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
   505——服务器不支持或拒绝支请求头中指定的HTTP版本
   ```

   

3. 什么是渐近增强，什么是优雅降级

   ```
   浏览器输入网址到页面渲染全过程 渐进增强：一开始就针对低版本浏览器进行构建页面，完成基本的功
   能，然后在针对高级浏览器进行效果，交互，追加功能达到更好的体验。 优雅降级：一开始就构建站点
   的完整功能，然后针对浏览器测试和修复，比如一开始使用css3的特性构建一个应用，然后逐步针对各
   大浏览器进行hack使其可以在低版本浏览器上正常浏览。
   ```

   

4. 浏览器的地址栏输入url网址以后发生了哪些事情（自行查找答案回答，并记录）

   ```
   URL解析
   一个URL包括协议，网络地址，资源路径
   协议：最常用的比如HTTP（超文本传输协议）FTP（文件传输协议）
   网络地址：可以是域名或者ip地址，包括端口号，如果没有默认为80
   如果是不合法的地址，会转给默认的搜索引擎,例如如果你正在使用chrome，可以在url输入框输入你想要搜索的内容，然后搜索引擎会根据关键字进行搜索。
   
   DNS域名解析
   例如：baidu.com就是域名
   1.先到各种缓存信息中查找
   先到浏览器缓存记录中查找------浏览器会缓存DNS一段时间
   系统缓存-----如果浏览器中没有找到，浏览器会有一个系统调用，获得系统缓存中的记录
   路由器缓存-----接着将请求发给路由器，路由器一般也有自己的DNS缓存
   
   2.DNS服务器查找
   没有则发送请求到本地域名服务器每一个本地域名服务器都维护一个高速缓存，存放最近用过的域名及其IP地址.如果还没有则发出递归查询（本地服务器请求比他高一级的服务器，如此递归直到根域名服务器，肯定能找到这个服务器的IP地址）通过这个IP可以找到客户端到服务器端的唯一路径.
   
   3、浏览器主机根据ip地址与服务器建立TCP连接
   浏览器向服务器端发送SYN连接请求，经过服务器与浏览器三次报文的交互连接建立完成，就可以发送数据了。
   找到了正确的IP地址以后就要开始建立连接了，建立连接的过程一般会使用TCP协议，通过三次握手建立连接。
   TCP 三次握手
   客户端发出建立连接的请求。数据包携带有SYN。
   如果服务端有开放的端口，可以接受并建立连接，那么服务端会返回SYN + ACK,告诉客户端我可以接受你的请求。
   客户端收到服务端的回应，发送ACK给服务端。 连接建立。
   4、发送HTTP请求
   与服务器建立了连接后，就可以向服务器发起请求了
   请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述
   5、服务器处理请求
   服务器收到请求并响应，生成一个HTTP响应报文，通过TCP协议发送给浏览器主机
   通过HTTP请求服务后，服务器会像浏览器返回一个应答信息----------HTTP响应
   在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。
   
   6、断开TCP连接
   为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。
   客户端发起中断请求，发送FIN到服务端
   服务端收到请求，可能数据还没有发完。这个时候不会关闭socket，而是回复ACK，告诉客户端知道了
   客户端进入Fin_Wait状态，继续等待服务端端的FIN报文。服务端端发送完毕后，会向客户端发送FIN
   客户端客服端收到后就回复ACK，并关闭连接
   
   7、浏览器解析文件
   
   浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
   要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，（js阻塞问题可以自行百度，或者等我有时间更新一篇文章，单独解释阻塞）
   
   8、浏览器布局渲染
   根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：repaint(重绘)和reflow(回流)。
   
   repaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
   
   
   reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。
   
   所以我们应该尽量减少reflow和repaint,良好的css规范会减少这种操作,传送门·CSS书写规范和顺序
   最后浏览器绘制各个节点，将页面展示给用户。
   
   
   
   ```

   

5. 下面的代码有什么区别

   ```html
   <script src="./1.js" async></script>
   <script src="./1.js" defer></script>
   
   defer:这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<script>元素上设置defer属性，相当于告诉浏览器立即下载，但延迟执行。
      
   async:从改变脚本处理方式上看，async属性与defer类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与defer不同的 是，标记为async的脚本并不保证能按照它们出现的次序执行。
   ```

   > defer和async属性的区别，查询红宝书，现在已经不在使用这种方式了，但是可能会在面试当中见到

6. 重排(layout)和重绘(repaint)？【自行百度】

   ```
   reflow： 当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。
   repaint:当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。
   ```

   

7. 什么是标准盒子模型，什么是怪异盒子模型

   ```
   标准盒子模型和怪异盒子模型（IE盒子模型） 在标准模式下，一个块的总宽度 = 内容的width + padding(左右) + border(左右) + margin(左右)
   在怪异模式下，一个块的总宽度 = 内容的width + margin(左右)（这里的width包含了padding(左右)和border(左右)的值）
   ```

   

8. js的数据类型有哪些？null与undefined有哪些区别？

   ```
   基本数据类型number,string,boolean,null,undefined,bigInt,symbol 复杂数据类型Object,set,map
   值是undefined的变量和未声明的变量，typeof运算结果都是“undefined”。运算符typeof运算null的类型时返回“object”。
   undefined不会被分配内存空间，null会被分配
   ```

   

9. `var,let,const`三者有什么区别？

   ```
   var在执行上下文中,有建立阶段，let和const没有建立阶段。var不会建立块级作用域，let和const会建立块级作用域。同一作用域中var可以重复声明，let和const不能重复声明。var和let声明时并不一定要定义（初始化）,可以改变值,const必须要声明同时定义,不能改变值(锁栈)。
   ```

   

10. 说一说什么是模板字符串？

  ```
  模板字符串用反引号`进行包裹，里面会保留空格与换行符，可以通过$()来填写变量、js表达式
  ```

  

11. 箭头函数与普通函数有什么区别？

    ```
    箭头函数用()=>{}来定义，箭头函数只能声明成匿名函数，但可以通过表达式的方式让箭头函数具名,
    声明一个普通函数需要使用关键字function来完成，并且使用function既可以声明成一个具名函数也可以声明成一个匿名函数
    其中的this指向上一个作用域，当形参只有一个时可以省略(),当函数体只有返回一条语句时可以省略{}与return
    箭头函数的this永远不会变，call、apply、bind也无法改变
    箭头函数没有原型prototype
    箭头函数不能当成一个构造函数
    箭头函数没有自己的arguments(可以使用rest参数代替)
    箭头函数不能重复函数参数名称
    ```

    

12. `for...in`的遍历与`for...of`的遍历有什么区别？

    ```
    for...in 遍历得到 key
    for...of 遍历得到 value
    for...in可以用在可枚举的数据（enumerable）
    for...of用于可迭代的数据（iterable）
    ```

    

13. 请简单的介绍一下什么是解构？

    ```
    分解其中一种数据类型并将其单独的属性分配给变量
    ```

    

14. ES6里面新增的2种**数据结构**是什么？

    ```
    set,map
    ```

    

15. `Map`与`WeakMap`有什么区别？

    ```
    Map的键和值都可以是任意类型，而WeakMap的键只能是对象。
    Map和WeakMap的键必须唯一，判断方式是“===”和是否地址相同。
    Map视NaN为同一个键。
    WeakMap中的键值对的键是弱引用，WeakMap中的成员随时会消失
    ```

    

16. `Promise`内部的状态有哪些？

    ```
    Pending（进行中，初始状态，既不是成功，也不是失败状态。）、Resolved（已完成，又称 Fulfilled）、Rejected（已失败）
    ```

    

17. 请根据你自身的理解，来解释一下什么是闭包？闭包的缺点是什么？

    ```
    声明一个变量，声明一个函数，在函数内部访问外部的变量，那么这个函数加这个变量叫做闭包
    1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
    2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
    ```

    

18. 请说一下什么是Ajax，ajax的创建过程是什么样的？

    ```
    Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）,是一种浏览器向http/https服务器发起请求的 一种方式，只是这种方式是一种异步的方式
    ```

    

19. 简单的说明一下什么是跨域【先自行百度查找结果，后面会讲到】

    ```
    CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问就会遇到跨域问题
    ```

    

20. 什么是深拷贝，用你所知道的方法实现一个复杂对象的深拷贝

    ```
    建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用” 我们希望在改变新的数组（对象）的时候，不改变原数组（对象）
    //深拷贝
        function deepCopy(oldObj) {
            if (typeof oldObj != "Object" || oldObj === null) {
                return oldObj
            }
            const newObj = Array.isArray(oldObj) ? [] : {};
            let arr = Object.getOwnPropertyNames(oldObj);
            arr.forEach((item) => {
                newObj[item] = deepCopy(oldObj[item]);
            });
            return newObj;
        }
    ```

    

21. 什么是同步，什么是异步？请列举几个典型的异步场景

    ```
    一个进程中需要执行某个请求时，如果这个请求需要等待一段时间，那么进程就会一直等下去，直到请求结果返回，这就是同步
    异步的区别就是不会继续等待下去，会继续执行进程，当请求消息返回时再进行处理请求结果
    
    ```

    

22. 描述一下浏览器事件机制？

    ```
    浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。
    
    常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。
    常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。
    
    开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
    
    
    全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。
    
    
    上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
    
    执行渲染操作，更新界面
    
    检查是否存在 Web worker 任务，如果有，则对其进行处理
    
    上述过程循环往复，直到两个队列都清空
    ```

    

23. 介绍一下你对浏览器内核的理解？

    ```
    简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。
    浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
    
    GUI 渲染线程
    JavaScript引擎线程
    定时触发器线程
    事件触发线程
    异步http请求线程
    
    1.GUI渲染线程
    
    主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
    当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
    该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。
    
    2.JS引擎线程
    
    该线程当然是主要负责处理 JavaScript脚本，执行代码。
    也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。
    当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。
    
    3.定时器触发线程
    
    负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
    主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。
    
    4.事件触发线程
    
    主要负责将准备好的事件交给 JS引擎线程执行。
    
    比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。
    5.异步http请求线程
    
    负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。
    主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。
    
    ```

    

24. 三栏式布局如何设计？

    ```
    绝对定位，左右两栏设置绝对定位，中间一栏设置对应方向大小的margin值
    flex布局，左右设置放大缩放为0，并设置固定大小，中间一栏设置为auto
    浮动，
    ```

    

25. 解释一下BFC

    ```
    块级格式上下文（BFC），一个元素形成BFC之后，其内部的元素的布局不会影响外部布局，外部元素的布局也不会影响内部布局。一个BFC区域就像一个隔离区域，和其他区域互不影响。
    
    根元素是一个BFC区域，浮动和绝对定位会让元素成为BFC区域，display属性的值为inline-block、flex、root-flow这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。
    ```

    

26. ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。

    ```
    单冒号表示伪类，双冒号表示伪元素，一些浏览器为了兼容也可以用单冒号表示伪元素。伪类是指元素的特殊状态：hover，link等，伪元素一般时特殊的位置，如after,before等
    ```

    

27. 怎么让Chrome支持小于12px 的文字？

    ```
    -webkit-text-size-adjust:none (已被弃用)
    使用transfrom来进行缩放-webkit-transform:scale(0.5)，该属性收缩的是整个元素，有时需要将内联元素转换为块元素
    使用图片
    ```

    

28. 设置元素浮动后，该元素的display值是多少？

    ```
    display:block
    ```

    

29. 你对line-height是如何理解的？ line-height:1 是什么意思

    ```
    line-height设置为数字表示字体大小乘以该数字，1表示一倍文字高度，一般情况默认1.2
    ```

    

30. [“1”, “2”, “3”].map(parseInt) 答案是多少？

    ```
    [1,NaN,NaN] parseInt（String,radix）,其中radix范围是2-36。parseInt被传入三个参数（element,index,arr),但是只接受了element,index，所以三次的循环参数为(1,0),(2,1),(3,2),只有第一次中的0被认为转换为十进制，输出为1，其他情况都不在2-36之间，返回NaN。
    ```

    

31. new操作符具体干了什么呢?

    ```
    创建一个空对象
    将空对象的原型指向构造函数的prototype属性
    将空对象赋值给构造函数的this
    执行构造函数内部中的代码
    判断返回对象，如果是值类型就返回对象，如果是引用类型就返回这个引用类型的对象
    ```

    

32. .call() 和 .apply() 的含义和区别？

    ```
    二者第一个参数表示this要指向的对象，null或者undefined表示绑定全局对象。二者区别在于第二个参数，.apply()的第二个参数需要传入数组，数组的成员都会一个一个传入原函数作为参数，而.call()则必须一个个添加来作为传入函数的参数。
    ```

    

33. jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？【返回this就可以实现链式语法，自行查找答案】

    ```
    jQuery对象
    为了实现链式调用
    ```

    

34. jquery.extend 与 jquery.fn.extend的区别？

    ```
    JQuery.extend的this指向JQuery本身，
    JQuery.fn.extend的this指向JQuery实例对象，也就是$(‘div’)
    ```

      

35. 谈一下Jquery中的bind(),live(),delegate(),on()的区别？

    ```
    bind()的特点：直接绑定在已经存在的元素上，但是对在它执行完后动态添加的那些元素上不起作用。因为直接绑定在具体的元素上，响应事件及时，它是出现最早的一种绑定事件的方法。这种方法很浪费资源，引起性能问题，因为它要匹配选择器中的每一项并且挨个设置相同的事件处理程序。如果在页面加载前要处理添加事件的话，会影响加载效率的。在jquery1.7版本以前比较受推崇。在jquery1.7版本之后，官方推荐使用on()方法代替。在jquery3.0版本之后，已经删除该方法。
    
    live()的特点：与bind()的实现原理却不同。live()方法附加事件处理程序在document上通过冒泡来关联匹配到相应的元素和事件信息。对新添加的元素依然有效。不需要在每个元素上去绑定事件，而只在document上绑定一次就可以了。可以在document ready之前就可以绑定那些需要的事件。但是jquery1.9版本之后，已经被弃用了。
    
    delegate()方法的特点：更精确的小范围使用事件代理，性能优于live()。它可以自由选择附加的选择器和事件信息的位置，把事件绑定到具体元素的上一级较稳定（不会动态地添加或者删除、变化）的元素上，缩短了事件冒泡的路径。同样对新添加的元素依然有效。在jquery3.0版本之后，已经删除该方法。
    
    on()的特点：是以上三种方法的统一。可以使用一个方法，设置不同参数值来实现上述三种方法的功能。简化了jQuery代码库，并删除一个界别的重定向。
    
    ```

    

36. rgba()和 opacity 的透明效果有什么不同？

    ```
    rgba 只对颜色有影响。如果放在 background 上的话，只对背景颜色有影响。不会影响元素中的其他内容以及子元素内容。
    
    opacity 的透明效果是作用整个元素以及其子元素上的。
    ```

    

37. 浮动以后的元素怎么居中?

    ```
    加一层父级div：在需要居中的浮动元素（A）外加一层父级div（B），并且A和B宽度width相等，给父级div加margin: 0 auto;
    浮动元素绝对定位，父级元素相对定位，left,top都设置50%，此时子元素的左顶点在页面中间，设置transform:translate(-50%,-50%);子元素页面居中
    ```

    

38. 浏览器的内核有哪些？

    ```
    Trident内核
    代表作品是IE，俗称IE内核；使用IE内核的浏览器包括、傲游、世界之窗、百度浏览器、兼容模式的浏览器等
    WebKit内核
    代表作品是Safari、旧版的Chrome
    Presto内核
    代表作品是Opera，Presto是由Opera Software开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在13年之后，Opera宣布加入谷歌阵营，弃用了 Presto
    Blink内核
    代表作品是Chrome、Opera；由Google和Opera Software开发的浏览器排版引擎
    Gecko内核
    代表作品是Firefox，俗称Firefox内核
    Chromium内核
    这个比较特殊，Chromium是谷歌的开源项目是一款浏览器，Chrome 是Chromium的稳定版。国内的大部分双核浏览器都采用Chromium内核
    
    ```

    

39. javascript的 typeof 的返回值有哪些？

    ```
    number, boolean, string, undefined, object, function,symbol,其中 typeof null会返回object
    ```

    

40. jQuery里面的event对象与DOM里面的event对象有什么区别，如果通过jQuery的event对象找到 JS的event对象

    ```
    jQuery的event是在dom的event对象上的进一步封装，event.target
    ```

    

41. `foo=foo||bar ;`这句代码是什么意思？

    ```
    foo 为false时会将bar赋值给foo
    ```

    

42. link与@import的区别在哪里？

    ```
    1. 从属关系
            1.1  link：link是HTML提供的标签，不仅可以加载CSS，还可以定义rel等属性
            1.2  @import：@import是css提供的语法，只有导入样式表的作用
    
        2. 加载顺序
            2.1   link：link在页面加载时CSS同时被加载
            2.2  @import：引入的CSS要等页面加载完毕后再加载
    
        3. 兼容性问题
            3.1  link是HTML提供的语法，不存在兼容性问题
            3.2  @import是css2.1提供的语法，ie5以上才兼容
    
        4. DOM可控性
            js控制DOM时，可以通过插入link标签来改变样式，不能通过@import改变
    
        5. 权重问题（有争议）
            link标签引入的样式权重大于@import标签
    
    ```

    

43. 下面这个 ul，如何点击每一列的时候 alert 其 index?（闭包或let）

    ```html
    <ul id=”test”>
        <li>这是第一条</li>
        <li>这是第二条</li>
        <li>这是第三条</li>
    </ul>
    ```

    ```javascript
    let ul1 = document.querySelector("#test");
        let lis = document.querySelectorAll("#test>li");
        console.log(lis);
        ul1.addEventListener("click", function (event) {
            for (let i = 0; i < lis.length; i++) {
                if (event.target === lis[i]) {
                    alert(i);
                }
            }
        })
    ```

    

44. 下面代码执行的结果是什么

    ```javascript
    (function(x){
        delete x;
        alert(x);
    })(1+5);)
    ```

45. `window.onload`与`document.ready`的区别

    ```
    一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。
    ```

    

46. 问：0.1 + 0.2 ！=0.3，js里面这种计算不准备的问题怎么解决？

    ```
    我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。
    
    我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以
    使用 es6 的 Number.EPSILON
    ```

    

47. `Symbol`有什么用处？

    ```
    每个属性的名字都是独一无二的，防止属性名的冲突。
    ```

    

48. 什么是会用域，ES5与ES6中的作用域有什么区别？

    ```
    ES6中的作用域包括块级作用域于全局作用域，而es5只有全局作用域，而且二者都有函数作用域
    ```

    

49. 事件委托是什么？

    ```
    事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到
    目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。
    
    使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
    ```

    

50. 下面代码打印的顺序是什么？

    ```javascript
    console.log(1)
    
    setTimeout(function(){
    	console.log(2)
    },0)
    
    console.log(3)
    
    setTimeout(function(){
    	console.log(4)
    },1000)
    
    console.log(5)
    // 1 3 5 2 4
    ```

51. DOM中的`attribute`与`property`有什么区别？

    ```
    property是DOM中的属性，是JavaScript里的对象；
    attribute是HTML标签上的特性，它的值只能够是字符串；
    ```

    

52. meta 有哪些常见的值？

    ```
    content 属性 必选属性  始终要和 name 属性或 http-equiv 属性一起使用。即而是当有http-equiv或name属性的时候，一定要有content属性对其进行说明。
    name 属性 可选属性
    http-equiv 属性 可选属性 并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。
    ```

    

53. 简述 src 和 href 的区别？

    ```
    src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。
    ```

    

54. px，em，rem，vw 有什么区别？

    ```
    px:像素大小
    em：设定font-size的大小，如果没有就是父元素的font-size
    rem:对于根元素html（网页）的font-size
    vw:视窗宽度，1vw等于视窗宽度的1%
    ```

    

55. line-height: 2; 和 line-height: 200%; 有什么区别?

    ```
    line-height: 2;表示文字大小的两倍
    line-height: 200%;表示当前元素高度的两倍
    ```

    

56. 如下代码的输出？为什么？

    ```javascript
    sayName("world");  // hello world
    sayAge(10);  //报错
    function sayName(name) {
        console.log("hello ", name);
    }
    var sayAge = function(age) {
        console.log(age);
    };
    
    // hello world
    // Uncaught TypeError: sayAge is not a function
    函数和变量都会有主动提升，sayName能够正常被识别，而sayAge只是被声明没有被赋值，所以没有被认为是一个函数
    ```

57. 以下代码输出什么？

    ```javascript
    var name = "sex"
    var company = {
        name: "qdywxs",
        age: 3,
        sex: "男"
    }
    console.log(company[name]) //男
    ```

58. 以下代码输出什么？

    ```javascript
     var name = "sex"
     var company = {
         name: "qdywxs",
         age: 3,
         sex: "男"
     }
     console.log(company.name) //qdyws
    ```

59. `Object.create()` 有什么作用？

    ```
    该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。
    ```

    

60. 补全代码，实现继承

    ```javascript
    function Person(name, sex){
        // 补全
        this.name = name;
        this.sex=sex;
        
    };
    Person.prototype.getName = function() {
        // 补全
        return this.name;
    };
    function Male(name, sex, age) {
        // 补全
        this.age = age;
        Person.call(this,name,sex);
    };
    Male.property=Object.create(Person.property);
    Male.property.constructor = Male; 
    // 补全
    Male.prototype.getAge = function() {
        // 补全
        return this.age;
    };
    var catcher = new Male("Oli", "男", 2);
    catcher.getName();
    ```

    

